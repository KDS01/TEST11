## Dependency
	- 의존성
## Dependency relationship
	- 어떠한 코드를 수행함에 있어 다른 라이브러리,코드가 무조건적으로 필요할 때, 의존 관계에 있다고 말한다.
	
## Dependency Injection
	- 의존 관계 주입
	- 의존성 주입
	- 런타임이 되서야 의존 관계가 연결된다(컴파일 단계에서는 X)
	
### 의존 관계 주입 규칙	
	- 내부에서 new로 새로이 메모리 영역을 할당하는 것이 아닌, 클래스 외적인 부분에서 이미 생성한 인스턴스 객체를 전달받아야 한다.
	- 인터페이스만 사용해야한다.
	- 의존 관계 주입을 할 때, 클래스 외부에서 결정된다.
### 의존 관계 주입 방법
	- 생성자 단계에서 주입
		- 가장 많이 쓰이는 방법(안정적)
	- 일반 메서드 주입
		- 메모리의 할당과 해제가 자주 일어남
		- new로 생성할 때/ 메서드가 종료될 때
	- setter 주입
		- 생성자 주입과 크게 다르지 않다.
		- 불변성이 깨질 수 있다(생성자와 다른 점).	
### Dependency Lookup
	- 의존 관계 검색
#디자인 패턴
	-코드 구현을 할 때, 어떠한 방식으로 구현을 할 것인가에 대한 방법론
	
## 전략 패턴
	-변화할 수 있는 내용에 대해서 외부에서 결정할 수 있게 만들어준다.
	
## 싱글톤
	-하나의 인스턴스 객체로 작업을 할 수 있도록 한다.
## 프로토타입 패턴(js)
	- 클래스와 정 반대의 개념
	- 객체지향을 지양하기 위해 사용한다
	- (객체지향) Class 생성	>인스턴스 생성	> 메모리를 할당하여 데이터를 생성한 후에 사용.
	- 프로토타입 => 객체를 바로 생성해서 사용한다. 클래스 개념을 만들었을 때, 상속을 한다 라고 얘기한다면, 프로토타입은 상위 클래스가 아닌, 다른 객체를 연결한다.
	

# IoC
	-
	-
##우리가 스프링에 요청(userdao 주세요) => Application context에게 요청 => bean을 거쳐 factory에게 전달(AC에 설정(factory.class))
		->("UserDAO.class"로 타입을 선언해두면, 해당 클래스의 형식에 맞춰서 getBean에게 전달) => getbean을 통해 유저에게 전달
		->("UserDAO"만 선언시, 생성자 메서드를 불러오게 된다 but 우리가 필요한 건 클래스 그 자체)
		-getBean("userDAO", UserDAO.class);
		-AC는 내부적으로 봤을 때, 팩토리를 상속받고 있다?????
			=>